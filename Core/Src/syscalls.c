/**
 * @file      syscalls.c
 * @brief     Newlib C 라이브러리용 시스템 콜 최소 구현 모듈
 *
 * Newlib(GCC ARM 임베디드 표준 라이브러리)가 요구하는 저수준 시스템 콜
 * 함수들의 최소 구현을 제공한다.
 *
 * @details 구현된 시스템 콜:
 * | 함수         | 동작                                          |
 * |--------------|-----------------------------------------------|
 * | _read()      | 문자 입력 (약한 링크, __io_getchar() 사용)   |
 * | _write()     | 문자 출력 (약한 링크, __io_putchar() 사용)   |
 * | _close()     | 항상 -1 반환 (파일 시스템 없음)              |
 * | _fstat()     | S_IFCHR 반환 (문자 장치로 처리)              |
 * | _isatty()    | 항상 1 반환 (터미널로 처리)                  |
 * | _lseek()     | 항상 0 반환 (탐색 불가)                      |
 * | _open()      | 항상 -1 반환 (파일 열기 불가)               |
 * | _getpid()    | 항상 1 반환                                  |
 * | _kill()      | EINVAL 반환                                  |
 * | _exit()      | 무한 루프 (복귀 불가)                        |
 *
 * @note __io_putchar() 및 __io_getchar()를 구현하면 printf/scanf가 동작한다.
 *       (예: UART를 통한 ITM/SWO 출력)
 *
 * @author  STMicroelectronics (Auto-generated by STM32CubeIDE)
 * @date    2020-2025
 *
 * @attention
 * Copyright (c) 2020-2025 STMicroelectronics. All rights reserved.
 */

/* Includes */
#include <sys/stat.h>
#include <stdlib.h>
#include <errno.h>
#include <stdio.h>
#include <signal.h>
#include <time.h>
#include <sys/time.h>
#include <sys/times.h>


/* Variables */
extern int __io_putchar(int ch) __attribute__((weak));
extern int __io_getchar(void) __attribute__((weak));


char *__env[1] = { 0 };
char **environ = __env;


/* Functions */
void initialise_monitor_handles()
{
}

int _getpid(void)
{
  return 1;
}

int _kill(int pid, int sig)
{
  (void)pid;
  (void)sig;
  errno = EINVAL;
  return -1;
}

void _exit (int status)
{
  _kill(status, -1);
  while (1) {}    /* Make sure we hang here */
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
  {
    *ptr++ = __io_getchar();
  }

  return len;
}

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
  {
    __io_putchar(*ptr++);
  }
  return len;
}

int _close(int file)
{
  (void)file;
  return -1;
}


int _fstat(int file, struct stat *st)
{
  (void)file;
  st->st_mode = S_IFCHR;
  return 0;
}

int _isatty(int file)
{
  (void)file;
  return 1;
}

int _lseek(int file, int ptr, int dir)
{
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
}

int _open(char *path, int flags, ...)
{
  (void)path;
  (void)flags;
  /* Pretend like we always fail */
  return -1;
}

int _wait(int *status)
{
  (void)status;
  errno = ECHILD;
  return -1;
}

int _unlink(char *name)
{
  (void)name;
  errno = ENOENT;
  return -1;
}

int _times(struct tms *buf)
{
  (void)buf;
  return -1;
}

int _stat(char *file, struct stat *st)
{
  (void)file;
  st->st_mode = S_IFCHR;
  return 0;
}

int _link(char *old, char *new)
{
  (void)old;
  (void)new;
  errno = EMLINK;
  return -1;
}

int _fork(void)
{
  errno = EAGAIN;
  return -1;
}

int _execve(char *name, char **argv, char **env)
{
  (void)name;
  (void)argv;
  (void)env;
  errno = ENOMEM;
  return -1;
}
